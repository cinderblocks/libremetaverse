/*
 * Copyright (c) 2006-2016, openmetaverse.co
 * Copyright (c) 2025, Sjofn LLC.
 * All rights reserved.
 *
 * - Redistribution and use in source and binary forms, with or without 
 *   modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * - Neither the name of the openmetaverse.co nor the names 
 *   of its contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using OpenMetaverse.Packets;
using OpenMetaverse.Interfaces;

namespace OpenMetaverse
{
    /// <summary>
    /// Registers, unregisters, and fires events generated by incoming packets
    /// </summary>
    public class PacketEventDictionary
    {
        private sealed class PacketCallback
        {
            public readonly EventHandler<PacketReceivedEventArgs> Callback;
            public readonly bool IsAsync;
            public readonly EventHandler<PacketReceivedEventArgs>[] InvocationList;

            public PacketCallback(EventHandler<PacketReceivedEventArgs> callback, bool isAsync)
            {
                Callback = callback;
                IsAsync = isAsync;

                if (callback == null)
                {
                    InvocationList = Array.Empty<EventHandler<PacketReceivedEventArgs>>();
                }
                else
                {
                    var dels = callback.GetInvocationList();
                    var list = new EventHandler<PacketReceivedEventArgs>[dels.Length];
                    for (int i = 0; i < dels.Length; i++)
                    {
                        list[i] = (EventHandler<PacketReceivedEventArgs>)dels[i];
                    }
                    InvocationList = list;
                }
            }

            public PacketCallback WithAdded(EventHandler<PacketReceivedEventArgs> add, bool isAsync)
            {
                return new PacketCallback(Callback + add, IsAsync || isAsync);
            }

            public PacketCallback WithRemoved(EventHandler<PacketReceivedEventArgs> remove)
            {
                var newCallback = Callback - remove;
                return new PacketCallback(newCallback, IsAsync);
            }
        }

        /// <summary>Reference to the GridClient object</summary>
        public GridClient Client;

        // Use ConcurrentDictionary to avoid locks on the hot read path
        private readonly ConcurrentDictionary<PacketType, PacketCallback> _EventTable =
            new ConcurrentDictionary<PacketType, PacketCallback>();

        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="client"></param>
        public PacketEventDictionary(GridClient client)
        {
            Client = client;
        }

        /// <summary>
        /// Register an event handler
        /// </summary>
        /// <remarks>Use PacketType.Default to fire this event on every 
        /// incoming packet</remarks>
        /// <param name="packetType">Packet type to register the handler for</param>
        /// <param name="eventHandler">Callback to be fired</param>
        /// <param name="isAsync">True if this callback should be run asynchronously, false to run it synchronous</param>
        public void RegisterEvent(PacketType packetType, EventHandler<PacketReceivedEventArgs> eventHandler, bool isAsync)
        {
            _EventTable.AddOrUpdate(packetType,
                key => new PacketCallback(eventHandler, isAsync),
                (key, existing) => existing.WithAdded(eventHandler, isAsync));
        }

        /// <summary>
        /// Unregister an event handler
        /// </summary>
        /// <param name="packetType">Packet type to unregister the handler for</param>
        /// <param name="eventHandler">Callback to be unregistered</param>
        public void UnregisterEvent(PacketType packetType, EventHandler<PacketReceivedEventArgs> eventHandler)
        {
            if (_EventTable.TryGetValue(packetType, out var existing))
            {
                var newCallback = existing.Callback - eventHandler;
                if (newCallback == null)
                {
                    // Remove the key entirely if no delegates remain
                    _EventTable.TryRemove(packetType, out _);
                }
                else
                {
                    // Try to update with the reduced delegate (conservative IsAsync kept)
                    _EventTable.TryUpdate(packetType, new PacketCallback(newCallback, existing.IsAsync), existing);
                }
            }
        }

        /// <summary>
        /// Fire the events registered for this packet type
        /// </summary>
        /// <param name="packetType">Incoming packet type</param>
        /// <param name="packet">Incoming packet</param>
        /// <param name="simulator">Simulator this packet was received from</param>
        internal void RaiseEvent(PacketType packetType, Packet packet, Simulator simulator)
        {
            // Create a single PacketReceivedEventArgs to avoid allocating one per handler
            var eventArgs = new PacketReceivedEventArgs(packet, simulator);

            // Use cached invocation arrays to avoid temporary list allocations
            EventHandler<PacketReceivedEventArgs>[] defaultAsync = null;
            EventHandler<PacketReceivedEventArgs>[] specificAsync = null;

            // Default handler first, if one exists
            if (_EventTable.TryGetValue(PacketType.Default, out var callback) && callback.Callback != null)
            {
                if (callback.IsAsync)
                {
                    defaultAsync = callback.InvocationList;
                }
                else
                {
                    try { callback.Callback(this, eventArgs); }
                    catch (Exception ex) { Logger.Log("Default packet event handler: " + ex, Helpers.LogLevel.Error, Client); }
                }
            }

            // Specific packet type handlers
            if (_EventTable.TryGetValue(packetType, out callback) && callback.Callback != null)
            {
                if (callback.IsAsync)
                {
                    specificAsync = callback.InvocationList;
                }
                else
                {
                    try { callback.Callback(this, eventArgs); }
                    catch (Exception ex) { Logger.Log("Packet event handler: " + ex, Helpers.LogLevel.Error, Client); }
                }

                // If specific handlers exist and are synchronous, we return after firing them
                if (specificAsync == null)
                    return; // all synchronous and already invoked
                // else fall through to queue async handlers
            }

            if (packetType != PacketType.Default && packetType != PacketType.PacketAck && (defaultAsync == null && specificAsync == null))
            {
                Logger.DebugLog("No handler registered for packet event " + packetType, Client);
            }

            // If there are async handlers, schedule a single work item to invoke them all without extra allocations
            if ((defaultAsync != null && defaultAsync.Length > 0) || (specificAsync != null && specificAsync.Length > 0))
            {
                var da = defaultAsync;
                var sa = specificAsync;

                // Use a small state object and a cached WaitCallback to avoid allocating a closure per call
                var state = new AsyncInvokeState(this, da, sa, eventArgs);
                ThreadPool.QueueUserWorkItem(s_asyncInvoker, state);
            }
        }

        // Small state object used to pass data to the shared static invoker
        private sealed class AsyncInvokeState
        {
            public readonly PacketEventDictionary Owner;
            public readonly EventHandler<PacketReceivedEventArgs>[] DefaultHandlers;
            public readonly EventHandler<PacketReceivedEventArgs>[] SpecificHandlers;
            public readonly PacketReceivedEventArgs EventArgs;

            public AsyncInvokeState(PacketEventDictionary owner,
                                    EventHandler<PacketReceivedEventArgs>[] defaultHandlers,
                                    EventHandler<PacketReceivedEventArgs>[] specificHandlers,
                                    PacketReceivedEventArgs eventArgs)
            {
                Owner = owner;
                DefaultHandlers = defaultHandlers;
                SpecificHandlers = specificHandlers;
                EventArgs = eventArgs;
            }
        }

        // Cached WaitCallback to avoid per-call delegate allocations
        private static readonly WaitCallback s_asyncInvoker = stateObj =>
        {
            var s = (AsyncInvokeState)stateObj;
            var owner = s.Owner;
            var da = s.DefaultHandlers;
            var sa = s.SpecificHandlers;
            var eventArgs = s.EventArgs;

            if (da != null)
            {
                for (int i = 0; i < da.Length; i++)
                {
                    var h = da[i];
                    try { h(owner, eventArgs); }
                    catch (Exception ex) { Logger.Log("Async Packet Event Handler: " + ex, Helpers.LogLevel.Error, owner.Client); }
                }
            }

            if (sa != null)
            {
                for (int i = 0; i < sa.Length; i++)
                {
                    var h = sa[i];
                    try { h(owner, eventArgs); }
                    catch (Exception ex) { Logger.Log("Async Packet Event Handler: " + ex, Helpers.LogLevel.Error, owner.Client); }
                }
            }
        };

        /// <summary>
        /// Public wrapper to invoke internal RaiseEvent for benchmarking and testing.
        /// </summary>
        public void InvokeRaiseEvent(PacketType packetType, Packet packet, Simulator simulator)
        {
            RaiseEvent(packetType, packet, simulator);
        }
    }

    /// <summary>
    /// Registers, unregisters, and fires events generated by the Capabilities
    /// event queue
    /// </summary>
    public class CapsEventDictionary
    {
        /// <summary>Reference to the GridClient object</summary>
        public GridClient Client;

        private readonly ConcurrentDictionary<string, Caps.EventQueueCallback> _EventTable =
            new ConcurrentDictionary<string, Caps.EventQueueCallback>();

        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="client">Reference to the GridClient object</param>
        public CapsEventDictionary(GridClient client)
        {
            Client = client;
        }

        /// <summary>
        /// Register a new event handler for a capabilities event sent via the EventQueue
        /// </summary>
        /// <remarks>Use String.Empty to fire this event on every CAPS event</remarks>
        /// <param name="capsEvent">Capability event name to register the 
        /// handler for</param>
        /// <param name="eventHandler">Callback to fire</param>
        public void RegisterEvent(string capsEvent, Caps.EventQueueCallback eventHandler)
        {
            _EventTable.AddOrUpdate(capsEvent,
                key => eventHandler,
                (key, existing) => existing + eventHandler);
        }

        /// <summary>
        /// Unregister a previously registered capabilities handler 
        /// </summary>
        /// <param name="capsEvent">Capability event name unregister the 
        /// handler for</param>
        /// <param name="eventHandler">Callback to unregister</param>
        public void UnregisterEvent(string capsEvent, Caps.EventQueueCallback eventHandler)
        {
            if (_EventTable.TryGetValue(capsEvent, out var existing) && existing != null)
            {
                var updated = existing - eventHandler;
                if (updated == null)
                {
                    _EventTable.TryRemove(capsEvent, out _);
                }
                else
                {
                    _EventTable.TryUpdate(capsEvent, updated, existing);
                }
            }
        }

        /// <summary>
        /// Fire the events registered for this event type synchronously
        /// </summary>
        /// <param name="capsEvent">Capability name</param>
        /// <param name="message">Decoded event body</param>
        /// <param name="simulator">Reference to the simulator that 
        /// generated this event</param>
        internal void RaiseEvent(string capsEvent, IMessage message, Simulator simulator)
        {
            bool specialHandler = false;

            // Default handler first (global), if one exists
            if (_EventTable.TryGetValue(string.Empty, out var callback) && callback != null)
            {
                try { callback(capsEvent, message, simulator); }
                catch (Exception ex) { Logger.Log("CAPS Event Handler: " + ex, Helpers.LogLevel.Error, Client); }
            }

            // Explicit handler next
            if (_EventTable.TryGetValue(capsEvent, out callback) && callback != null)
            {
                try { callback(capsEvent, message, simulator); }
                catch (Exception ex) { Logger.Log("CAPS Event Handler: " + ex, Helpers.LogLevel.Error, Client); }

                specialHandler = true;
            }

            if (!specialHandler)
                Logger.Log("Unhandled CAPS event " + capsEvent, Helpers.LogLevel.Warning, Client);
        }

        /// <summary>
        /// Fire the events registered for this event type asynchronously
        /// </summary>
        /// <param name="capsEvent">Capability name</param>
        /// <param name="message">Decoded event body</param>
        /// <param name="simulator">Reference to the simulator that 
        /// generated this event</param>
        internal void BeginRaiseEvent(string capsEvent, IMessage message, Simulator simulator)
        {
            bool specialHandler = false;

            // Default handler first (global), if one exists - run asynchronously
            if (_EventTable.TryGetValue(string.Empty, out var callback) && callback != null)
            {
                var cb = callback;
                Task.Run(() =>
                {
                    try { cb(capsEvent, message, simulator); }
                    catch (Exception ex) { Logger.Log("Async CAPS Event Handler: " + ex, Helpers.LogLevel.Error, Client); }
                });
            }

            // Explicit handler next - run asynchronously
            if (_EventTable.TryGetValue(capsEvent, out callback) && callback != null)
            {
                var cb = callback;
                Task.Run(() =>
                {
                    try { cb(capsEvent, message, simulator); }
                    catch (Exception ex) { Logger.Log("Async CAPS Event Handler: " + ex, Helpers.LogLevel.Error, Client); }
                });

                specialHandler = true;
            }

            if (!specialHandler)
                Logger.Log("Unhandled CAPS event " + capsEvent, Helpers.LogLevel.Warning, Client);
        }
    }

}
